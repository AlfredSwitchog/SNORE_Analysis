%% ============================================================
%  Label fMRI timepoints with sleep stage (W / N1 / N2 / N3)
%  Assumptions (updated):
%   - all_subjects: 1×N cell, each {i} is (slices×1) cell of 1×T_i numeric
%     where all slices in the same subject have equal length T_i,
%     but T_i can differ across subjects.
%   - TR = 2.5 s
%   - EEG leads fMRI by 2.5 s  -> fMRI t=0 aligns to EEG t=+2.5 s
%   - CSV has columns: clock start time, start, end, stage
%  Outputs created in workspace:
%   - time_s                        : T_first×1 (EEG-clock times) for first subject’s first slice
%   - stage_per_timepoint           : T_first×1 labels for first subject’s first slice
%   - time_s_by_subject             : 1×N cell; {s} is T_s×1 EEG-clock times
%   - stage_per_timepoint_by_subject: 1×N cell; {s} is T_s×1 labels
%   - stage_flags_by_subject        : 1×N cell; {s} is [nSlices_s × T_s] string matrix
% =============================================================

%% --------------- CONFIG ----------------
all_subjects_path  = '/Users/Richard/Masterabeit_local/SNORE_CSF_Data/Merged_Data/csf_mean_per_slice_pre_subject.mat';
csvFile            = '/Users/Richard/Masterabeit_local/EEG/SCORING_files';  % can be a single CSV file OR a folder containing per-subject CSVs
TR                 = 2.5;                  % seconds
eegLeadsSeconds    = 2.5;                  % EEG starts earlier by 2.5 s
outOfRangeLabel    = "NA";                 % label for out-of-range volumes
requireSameT       = true;                 % enforce same T within each subject
subjects_to_map    = [1];                   % e.g., [1 2 5]; empty [] => map all subjects

%% --------------- LOAD / CHECK fMRI SHAPE ---------------
Si = load(all_subjects_path);
assert(isfield(Si,'averaged_csf_data'), 'Variable "averaged_csf_data" not found in %s', all_subjects_path);
all_subjects = Si.averaged_csf_data;

assert(exist('all_subjects','var')==1, ...
    'Variable "all_subjects" must exist in the workspace.');

assert(iscell(all_subjects) && isvector(all_subjects), ...
    '"all_subjects" should be a 1×N cell array (one cell per subject).');

nSubjects = numel(all_subjects);
assert(nSubjects>=1, 'all_subjects appears empty.');

% Inspect first subject & slice
firstSubj = all_subjects{1};
assert(iscell(firstSubj) && size(firstSubj,2)==1, ...
    'Each subject should be a (slices×1) cell array.');

nSlices_1 = size(firstSubj,1);
assert(nSlices_1>=1, 'First subject has no slices.');

T_first = numel(firstSubj{1});
assert(T_first>=1, 'First slice has no timepoints.');

% Type checks + same-length per subject (no cross-subject constraint)
for s = 1:nSubjects
    subjCell = all_subjects{s};
    assert(iscell(subjCell) && size(subjCell,2)==1, ...
        'Subject %d entry must be a (slices×1) cell array.', s);
    nSlices_s = size(subjCell,1);
    assert(nSlices_s>=1, 'Subject %d has no slices.', s);
    if requireSameT
        T_s = numel(subjCell{1});
        for r = 2:nSlices_s
            assert(isvector(subjCell{r}) && isnumeric(subjCell{r}), ...
                'Subject %d slice %d is not numeric.', s, r);
            assert(numel(subjCell{r}) == T_s, ...
                'Within-subject length mismatch: subject %d slice %d has %d vols, expected %d.', ...
                s, r, numel(subjCell{r}), T_s);
        end
    end
end

%% --------------- DISCOVER / ASSIGN SCORING FILES ----------------
% Accept either a file path or a folder path in csvFile
isFolder = isfolder(csvFile);

% We'll produce a 1×nSubjects cell; each {s} is a string array of 1+ files for subject s
filesForSubject = cell(1, nSubjects);

if isFolder
    D = dir(fullfile(csvFile, '*.csv'));
    assert(~isempty(D), 'No CSV files found in folder: %s', csvFile);
    filePaths = arrayfun(@(d) fullfile(d.folder, d.name), D, 'UniformOutput', false);

    % Extract first integer in each filename as the subject index
    fileNums = nan(numel(filePaths),1);
    for i = 1:numel(filePaths)
        [~,fname,~] = fileparts(filePaths{i});
        tok = regexp(fname, '(?i)\D?(\d+)\D?', 'tokens', 'once'); % first number in name
        if ~isempty(tok)
            fileNums(i) = str2double(tok{1});
        end
    end

    % Build grouping: subject s -> all files whose number == s
    for s = 1:nSubjects
        idxs = find(fileNums == s);
        if ~isempty(idxs)
            filesForSubject{s} = string(filePaths(idxs));
        else
            filesForSubject{s} = strings(0,1); % none found
        end
    end

    % Fallback for subjects without numbered files:
    % If you want a fallback, uncomment the block below to assign remaining files
    % by natural filename order (WARNING: cannot infer split-grouping in fallback).
    %
    %{
    [~, natOrder] = sort_nat(filePaths); used = false(size(filePaths));
    for s = 1:nSubjects
        if ~isempty(filesForSubject{s}), used(ismember(1:numel(filePaths), find(fileNums==s))) = true; end
    end
    for s = 1:nSubjects
        if isempty(filesForSubject{s})
            nextIdx = find(~used(natOrder), 1, 'first');
            if ~isempty(nextIdx)
                used(natOrder(nextIdx)) = true;
                filesForSubject{s} = string(filePaths(natOrder(nextIdx)));
            end
        end
    end
    %}

    fprintf('Scoring file assignment:\n');
    for s = 1:nSubjects
        if isempty(filesForSubject{s})
            fprintf('  Subject %d  <--  [NO FILES FOUND]\n', s);
        else
            listStr = strjoin(filesForSubject{s}, ', ');
            fprintf('  Subject %d  <--  %s\n', s, listStr);
        end
    end

else
    % Single file: use same scoring file for all subjects
    for s = 1:nSubjects
        filesForSubject{s} = string(csvFile);
    end
    fprintf('Using single scoring file for all %d subjects: %s\n', nSubjects, csvFile);
end


%% --------------- PER-SUBJECT LABELING ----------------
stage_flags_by_subject         = cell(1, nSubjects);  % {s}: [nSlices_s × T_s] string matrix
time_s_by_subject              = cell(1, nSubjects);  % {s}: T_s×1 EEG-clock times
stage_per_timepoint_by_subject = cell(1, nSubjects);  % {s}: T_s×1 labels

% Which subjects to actually map?
if isempty(subjects_to_map)
    subjects_to_map_mask = true(1, nSubjects);
else
    subjects_to_map_mask = false(1, nSubjects);
    subjects_to_map_mask(subjects_to_map(subjects_to_map>=1 & subjects_to_map<=nSubjects)) = true;
end

for s = 1:nSubjects
    subjCell  = all_subjects{s};
    nSlices_s = size(subjCell,1);
    T_s       = numel(subjCell{1});

    % Build fMRI and EEG-clock times for this subject
    t_fmri_s   = (0:T_s-1)' * TR;           % fMRI clock
    time_eeg_s = t_fmri_s + eegLeadsSeconds;

    if subjects_to_map_mask(s)
        % --- Mapped subjects: require >=1 scoring file ---
        if isempty(filesForSubject{s})
            warning('No scoring files found for subject %d. Filling with NA.', s);
            labels_s = repmat(outOfRangeLabel, T_s, 1);
        else
            % Read & merge all scoring files for this subject
            tbl = read_and_merge_scoring_tables(filesForSubject{s});
            edges = [tbl.start; tbl.end(end)];      % left-closed, right-open

            bin_s    = discretize(time_eeg_s, edges);   % NaN = out of range
            labels_s = repmat(outOfRangeLabel, T_s, 1);
            inRange  = ~isnan(bin_s);
            labels_s(inRange) = tbl.stage(bin_s(inRange));
        end
    else
        % --- Unmapped subjects: fill with NA (same length) ---
        labels_s = repmat(outOfRangeLabel, T_s, 1);
    end

    % Store
    time_s_by_subject{s}              = time_eeg_s;
    stage_per_timepoint_by_subject{s} = labels_s;
    stage_flags_by_subject{s}         = repmat(labels_s.', nSlices_s, 1);
end


%% --------------- BACKWARD-COMPATIBLE FIRST-SUBJECT OUTPUTS ---------------
time_s               = time_s_by_subject{1};
stage_per_timepoint  = stage_per_timepoint_by_subject{1};

%% --------------- SUMMARY (across all subjects) ---------------
all_labels_vector = strings(0,1);
for s = 1:nSubjects
    all_labels_vector = [all_labels_vector; stage_per_timepoint_by_subject{s}(:)]; %#ok<AGROW>
end
[labels_unique, ~, idxu] = unique(all_labels_vector);
counts = accumarray(idxu, 1);
disp('Stage counts across all subjects:');
disp(table(labels_unique, counts));

disp('First 20 volume labels (first subject):');
disp(stage_per_timepoint(1:min(20, numel(stage_per_timepoint))).');

%% ======================= HELPERS ===========================
function tbl = read_scoring_table(pathToCsv)
    % Read and normalize a scoring CSV into columns: start, end, stage
    % Robust to preamble lines (e.g., "Wonambi v7.11"), BOMs, odd headers,
    % and delimiter (, / ;) differences.

    % --- 1) Find the actual header row that contains start/end/stage ---
    lines = readlines(pathToCsv);
    if isempty(lines)
        error('read_scoring_table: file is empty: %s', pathToCsv);
    end

    headerIdx = NaN;
    delim = ',';
    for i = 1:numel(lines)
        L = strtrim(lines(i));
        if L == ""         % skip empty lines
            continue
        end
        % decide delimiter for this line
        cComma = count(L, ","); cSemi = count(L, ";");
        if cComma==0 && cSemi==0, continue; end
        thisDelim = iff(cSemi > cComma, ';', ',');

        toks = split(L, [",",";"]);
        toks = lower(strtrim(toks));
        canon = regexprep(toks, '[^a-z0-9]+', '');  % "clock start time" -> "clockstarttime"
        if any(canon=="start") && any(canon=="end") && any(canon=="stage")
            headerIdx = i;
            delim = thisDelim;
            break
        end
    end

    if isnan(headerIdx)
        error('Could not find a header row with "start","end","stage" in %s', pathToCsv);
    end

    % --- 2) Build import options (set properties AFTER creating opts) ---
    opts = detectImportOptions(pathToCsv, 'Delimiter', delim);
    % Prefer preserving original header names if supported
    try
        opts.VariableNamingRule = 'preserve';
    catch
        % older MATLAB: handled via readtable('PreserveVariableNames', true)
    end
    % Make sure the right header line is used
    if isprop(opts, 'VariableNamesLine'), opts.VariableNamesLine = headerIdx; end
    % On many versions, DataLines is a property (not a parameter)
    if isprop(opts, 'DataLines'),        opts.DataLines        = [headerIdx+1, Inf]; end

    % --- 3) Read table (be liberal with compatibility flags) ---
    try
        scoreTbl = readtable(pathToCsv, opts, 'TextType','string', 'PreserveVariableNames', true);
    catch
        try
            scoreTbl = readtable(pathToCsv, opts, 'PreserveVariableNames', true);
        catch
            scoreTbl = readtable(pathToCsv, opts);
        end
    end

    % --- 4) Locate the needed columns by canonical name ---
    varNames  = string(scoreTbl.Properties.VariableNames);
    canonVars = lower(regexprep(strtrim(varNames), '[^a-z0-9]+', ''));

    idxStart = find(canonVars == "start", 1);
    idxEnd   = find(canonVars == "end",   1);
    idxStage = find(canonVars == "stage", 1);

    assert(~isempty(idxStart) && ~isempty(idxEnd) && ~isempty(idxStage), ...
        'CSV %s must contain header columns: start, end, stage (in seconds).', pathToCsv);

    % --- 5) Extract columns and coerce types ---
    start_s = scoreTbl.(varNames(idxStart));
    end_s   = scoreTbl.(varNames(idxEnd));
    stage   = scoreTbl.(varNames(idxStage));

    if ~isnumeric(start_s), start_s = str2double(string(start_s)); end
    if ~isnumeric(end_s),   end_s   = str2double(string(end_s));   end
    stage = normalizeStageStr(string(stage));   % trims & maps Wake->W, etc.

    % --- 6) Canonical output table + basic checks ---
    tbl = table(start_s(:), end_s(:), stage(:), 'VariableNames', {'start','end','stage'});
    tbl = sortrows(tbl,'start');

    assert(all(tbl.end > tbl.start), 'Scoring %s: each interval must have end > start.', pathToCsv);
    assert(issorted(tbl.start),      'Scoring %s: start times must be sorted.', pathToCsv);
end

% tiny inline helper (avoids toolbox dependency)
function out = iff(cond, a, b), if cond, out = a; else, out = b; end, end


% tiny inline helper for conditional choice
function out = ifelse(cond, a, b), out = a; if ~cond, out = b; end, end


function out = normalizeStageStr(in)
    % Map common variants to canonical labels
    s = lower(strtrim(string(in)));
    out = strings(size(s));
    for i = 1:numel(s)
        si = s(i);
        if si == "" || ismissing(si)
            out(i) = "NA";
            continue
        end
        if contains(si, "wake") || si == "w"
            out(i) = "W";
        elseif si == "n1" || contains(si, "stage 1") || si == "s1"
            out(i) = "N1";
        elseif si == "n2" || contains(si, "stage 2") || si == "s2"
            out(i) = "N2";
        elseif si == "n3" || contains(si, "stage 3") || si == "s3" || contains(si,"sws")
            out(i) = "N3";
        elseif contains(si, "rem") || si == "r"
            out(i) = "R";
        else
            out(i) = upper(string(in(i)));
        end
    end
end

function [sortedNames, order] = sort_nat(names)
    % Natural sort for filenames (numbers in order: 2 < 10).
    % Accepts: char, string array, cellstr, or cell array of strings/chars.

    % Normalize to cell array of char row vectors
    if ischar(names)
        names = {names};
    elseif isstring(names)
        names = cellstr(names);  % string array -> cellstr
    elseif iscell(names)
        names = cellfun(@char, names, 'UniformOutput', false); % string->char if needed
    else
        error('sort_nat: input must be char, string, or cell array.');
    end

    % Left-pad numeric substrings so lexical sort becomes natural
    keys = regexprep(names, '(\d+)', '${sprintf(''%010d'', str2double($1))}');
    [~, order] = sort(keys);
    sortedNames = names(order);
end

function tbl = read_and_merge_scoring_tables(fileList)
    % Accept string array, cellstr, or char for one or more files.
    if ischar(fileList), fileList = string(fileList); end
    if iscell(fileList), fileList = string(fileList); end
    assert(~isempty(fileList), 'read_and_merge_scoring_tables: empty file list');

    % Read each file into canonical table
    T = cell(numel(fileList),1);
    for k = 1:numel(fileList)
        T{k} = read_scoring_table(char(fileList(k)));
    end

    % Concatenate and sort by start
    tbl = sortrows(vertcat(T{:}), 'start');

    % Validate no overlaps (allow contiguity)
    % If you expect small floating rounding, you can relax with a tiny tol.
    tol = 0;  % set to e.g., 1e-6 if needed
    assert(all( tbl.start(2:end) >= tbl.end(1:end-1) - tol ), ...
        'Merged scoring has overlapping intervals. Check split files.');
end

